name: Helm Chart E2E (KinD)

on:
  pull_request:
    paths:
      - 'helm/fume/**'
      - '.github/workflows/helm-e2e.yml'

permissions:
  contents: read

jobs:
  lint:
    name: Lint chart
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.14.4

      - name: Helm lint
        run: |
          helm lint ./helm/fume -f ./helm/fume/values-ci.yaml

      - name: Negative schema lint (expect failure on typo)
        run: |
          set -euo pipefail
          # Use --set to introduce unknown key 'storage.fhircache.enabled=true' which schema should reject.
          if helm lint ./helm/fume --set storage.fhircache.enabled=true >/tmp/lint-out.txt 2>&1; then
            echo "::error::Expected helm lint to fail on unknown key storage.fhircache"; cat /tmp/lint-out.txt; exit 1; fi
          echo "Negative lint test passed (unknown key storage.fhircache correctly caused lint failure)."
          grep -qi 'fhircache' /tmp/lint-out.txt || echo "Note: failure output did not include token 'fhircache' (output below)" && cat /tmp/lint-out.txt

      - name: Render manifests (sanity)
        run: |
          helm template fume ./helm/fume -f ./helm/fume/values-ci.yaml > /dev/null

  e2e:
    name: Install on KinD and verify rollout
    runs-on: ubuntu-latest
    needs: lint
    # Required repository secrets:
    #   DOCKERHUB_TOKEN:    DockerHub PAT/token (read-only scope recommended) for user 'outburnltd'
    #   FUME_LICENSE_B64:   Base64-encoded contents of license.key.lic
    # NOTE: Secrets are unavailable for PRs from forks; consider alternative trigger if needed.
    env:
      DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
      FUME_LICENSE_B64: ${{ secrets.FUME_LICENSE_B64 }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create KinD cluster
        uses: helm/kind-action@v1.9.0
        with:
          version: v0.23.0
          node_image: kindest/node:v1.29.4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: v1.29.4

      - name: Detect available storage class for PVC tests
        run: |
          set -euo pipefail
          echo "Listing storage classes:";
          kubectl get storageclass || true
          DEFAULT=$(kubectl get storageclass -o json | jq -r '.items[] | select(.metadata.annotations["storageclass.kubernetes.io/is-default-class"]=="true") | .metadata.name' | head -n1)
          if [ -z "$DEFAULT" ]; then
            for sc in standard local-path; do
              if kubectl get storageclass "$sc" &>/dev/null; then DEFAULT=$sc; break; fi
            done
          fi
          if [ -z "$DEFAULT" ]; then
            echo "::error::No usable storage class found (looked for default, standard, local-path)."
            exit 1
          fi
          echo "Detected storage class: $DEFAULT"
          echo "STORAGE_CLASS=$DEFAULT" >> $GITHUB_ENV

      - name: Setup Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.14.4

      - name: Create namespace
        run: |
          kubectl create namespace fume
      - name: Validate required repo secrets present
        run: |
          set -euo pipefail
          for v in DOCKERHUB_TOKEN FUME_LICENSE_B64; do
            if [ -z "${!v:-}" ]; then echo "::error::Missing required secret $v"; exit 1; fi
          done
          echo "All required secrets present."

      - name: Create Docker registry pull secret (fixed username outburnltd)
        run: |
          set -euo pipefail
          kubectl -n fume create secret docker-registry regcred \
            --docker-username="outburnltd" \
            --docker-password="${DOCKERHUB_TOKEN}" \
            --docker-server="https://index.docker.io/v1/"
          echo "Created regcred image pull secret"

      - name: Create license secret from base64
        run: |
          set -euo pipefail
          printf "%s" "$FUME_LICENSE_B64" | base64 -d > license.key.lic || { echo "::error::Failed to decode FUME_LICENSE_B64"; exit 1; }
          ls -l license.key.lic
          kubectl -n fume create secret generic fume-license --from-file=license.key.lic
          echo "License secret created"

      - name: Create application config secret (minimal)
        run: |
          set -euo pipefail
          kubectl -n fume create secret generic fume-secrets \
            --from-literal=FHIR_SERVER_BASE="https://example.com/fhir"
          echo "Application secret created"

      - name: Install chart (persistent fhirCache enabled)
        run: |
          set -euo pipefail
          if [ -z "${STORAGE_CLASS:-}" ]; then echo "::error::STORAGE_CLASS not set; storage class detection failed"; exit 1; fi
          echo "Installing chart with persistent fhirCache and real backend image"
          helm install fume ./helm/fume -n fume -f ./helm/fume/values-ci.yaml \
            --set image.pullSecret=regcred \
            --set storage.fhirCache.enabled=true \
            --set storage.fhirCache.size=1Gi \
            --set storage.fhirCache.accessMode=ReadWriteOnce \
            --set storage.fhirCache.storageClass="$STORAGE_CLASS"

      - name: Wait for backend rollout
        run: |
          set -euo pipefail
          kubectl -n fume rollout status statefulset/fume-backend --timeout=600s || {
            echo "StatefulSet rollout failed. Diagnostics:";
            kubectl -n fume describe statefulset fume-backend || true;
            kubectl -n fume get pods -l app.kubernetes.io/component=backend -o wide || true;
            kubectl -n fume describe pod fume-backend-0 || true;
            kubectl -n fume get events --sort-by=.metadata.creationTimestamp | tail -n 100 || true;
            exit 1;
          }

      - name: Assert fhir-cache PVC present and bound
        run: |
          set -euo pipefail
          kubectl -n fume get pvc
          if ! kubectl -n fume get pvc | grep -q 'fhir-cache'; then
            echo "::error::Expected fhir-cache PVC after install"; exit 1; fi
          kubectl -n fume get pvc -o json | jq -r '.items[] | select(.metadata.name | contains("fhir-cache")) | [.metadata.name, .status.phase, .spec.accessModes[0], .spec.resources.requests.storage] | @tsv'
          kubectl -n fume get statefulset fume-backend -o json | jq -r '.spec.volumeClaimTemplates[].metadata.name'
          if ! kubectl -n fume get statefulset fume-backend -o json | jq -r '.spec.volumeClaimTemplates[].metadata.name' | grep -q '^fhir-cache$'; then
            echo "::error::Missing fhir-cache volumeClaimTemplate"; exit 1; fi

      - name: Application readiness & version check
        run: |
          set -euo pipefail
          mkdir -p /tmp/fume-artifacts
          APP_VERSION=$(grep '^appVersion:' helm/fume/Chart.yaml | awk '{print $2}' | tr -d '"')
          EXPECTED_VERSION="fume-enterprise ${APP_VERSION}"
          echo "Expecting fume_version='${EXPECTED_VERSION}'"
          # Create a single prober pod to avoid kubectl run overhead / hanging on name reuse.
          if ! kubectl -n fume get pod fume-curl-prober >/dev/null 2>&1; then
            kubectl -n fume run fume-curl-prober --image=curlimages/curl:8.7.1 --restart=Never --command -- sh -c 'sleep 3600' >/dev/null 2>&1 || true
            # Wait a short period for image pull
            kubectl -n fume wait --for=condition=Ready pod/fume-curl-prober --timeout=60s || echo "Prober pod not yet Ready; continuing (curl may still work)"
          fi
          START_TIME=$(date +%s)
          TIMEOUT_SECONDS=240   # 4 minutes hard timeout
          INTERVAL=5
          ATTEMPT=0
          SUCCESS=0
          while true; do
            NOW=$(date +%s)
            ELAPSED=$((NOW-START_TIME))
            if [ $ELAPSED -ge $TIMEOUT_SECONDS ]; then
              echo "::error::Timeout (${TIMEOUT_SECONDS}s) waiting for application readiness";
              # Capture quick diagnostics before failing
              kubectl -n fume get pods -l app.kubernetes.io/component=backend -o wide || true
              kubectl -n fume logs fume-backend-0 --tail=120 || true
              break
            fi
            ATTEMPT=$((ATTEMPT+1))
            echo "[Attempt $ATTEMPT] Querying root endpoint (elapsed ${ELAPSED}s)";
            # Use exec into backend pod if curl exists there; fallback to prober pod.
            if kubectl -n fume exec fume-backend-0 -- which curl >/dev/null 2>&1; then
              RAW=$(kubectl -n fume exec fume-backend-0 -- curl -sS -m 4 --connect-timeout 2 -w "HTTPSTATUS:%{http_code}" http://localhost:42420/ || true)
            else
              RAW=$(kubectl -n fume exec fume-curl-prober -- sh -c 'curl -sS -m 4 --connect-timeout 2 -w "HTTPSTATUS:%{http_code}" http://fume-backend.fume.svc.cluster.local:42420/' || true)
            fi
            BODY="${RAW%HTTPSTATUS:*}"
            STATUS="${RAW##*HTTPSTATUS:}"
            if [ "$STATUS" = "200" ]; then
              if echo "$BODY" | jq -e '.fume_version' >/dev/null 2>&1; then
                FUME_VERSION=$(echo "$BODY" | jq -r '.fume_version')
                echo "Found fume_version=$FUME_VERSION"
                echo "$BODY" > /tmp/fume-artifacts/root-endpoint.json
                if [ "$FUME_VERSION" != "$EXPECTED_VERSION" ]; then
                  echo "::error::Version mismatch (expected $EXPECTED_VERSION got $FUME_VERSION)"; exit 1; fi
                echo "Version OK after ${ELAPSED}s (${ATTEMPT} attempts)"
                SUCCESS=1
                break
              else
                echo "Status 200 but missing fume_version key yet";
              fi
            else
              echo "Non-200 or no response (status='${STATUS:-none}')"
            fi
            sleep $INTERVAL
          done
          if [ $SUCCESS -ne 1 ]; then
            echo "::error::Application readiness check failed within timeout"; exit 1; fi
          # Clean up prober pod (best effort)
          kubectl -n fume delete pod fume-curl-prober --ignore-not-found --grace-period=0 --force >/dev/null 2>&1 || true

      - name: Check fhirCache folder population
        run: |
          set -euo pipefail
          # Allow initial package load up to 5 minutes (poll every 15s)
          TARGET_DIR='hl7.fhir.r4.core#4.0.1'
          for i in $(seq 1 20); do
            if kubectl -n fume exec fume-backend-0 -- sh -c "ls -1 /usr/fume/fhir-packages | grep -F '$TARGET_DIR'" >/dev/null 2>&1; then
              echo "Found expected FHIR package directory: $TARGET_DIR";
              kubectl -n fume exec fume-backend-0 -- sh -c "ls -1 /usr/fume/fhir-packages" > /tmp/fume-artifacts/fhir-cache-list.txt
              exit 0;
            fi
            if [ $i -eq 20 ]; then echo "::error::Did not find $TARGET_DIR in fhir-cache"; exit 1; fi
            sleep 15
          done

      - name: Gather diagnostics on failure
        if: failure()
        run: |
          set -euo pipefail
          mkdir -p /tmp/fume-artifacts
          echo "=== StatefulSet describe ===" > /tmp/fume-artifacts/statefulset.txt
          kubectl -n fume describe statefulset fume-backend >> /tmp/fume-artifacts/statefulset.txt || true
          echo "=== Pod describe ===" > /tmp/fume-artifacts/pod.txt
          kubectl -n fume describe pod fume-backend-0 >> /tmp/fume-artifacts/pod.txt || true
          echo "=== Pod logs (last 400 lines) ===" > /tmp/fume-artifacts/pod-logs.txt
          kubectl -n fume logs statefulset/fume-backend --tail=400 >> /tmp/fume-artifacts/pod-logs.txt || true
          echo "=== Application log files ===" > /tmp/fume-artifacts/app-logs.txt
          kubectl -n fume exec fume-backend-0 -- sh -c 'for f in /usr/fume/logs/*.log; do echo "--- $f (last 200) ---"; tail -n 200 "$f"; done' >> /tmp/fume-artifacts/app-logs.txt || true

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: fume-e2e-artifacts
          path: /tmp/fume-artifacts

      - name: Basic smoke listing (always)
        if: always()
        run: |
          kubectl -n fume get all
          kubectl -n fume get pvc || true
          kubectl -n fume get events --sort-by=.metadata.creationTimestamp | tail -n 50 || true
